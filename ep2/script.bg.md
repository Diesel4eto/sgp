# Minimum Coin Change Problem
## Ресто с най-малък брой монети

Coin change problem или как да върнем ресто с най-малък брой монети е интересна задача с елегантно решение, която използва техниката _динамично програмиране_.

Задачата е следната: имаме конкретна сума пари, която трябва да върнем. За по-лесно, нека превърнем сумата до такава само в стотинки. Разполагаме с монети от всяка деноминация (т.е. имаме монети от 1, 2, 5, 10, и т.н стотинки). Целта е да я разбием на монети, така че броят на монетите да бъде възможно най-малък. 

Задачата може да се реши с brute force (или на български метода на "грубата сила") - с други думи да пробваме всички комбинации от монети, с които може да представим сумата и да изберем тази комбинация, която има най-малко монети. Това е валидно, но крайно неефективно решение.

Друга стратегия би била да избираме най-голямата деноминация, която ни доближава най-бързо до желаната сума. Този алгоритъм се нарича _greedy_ (или на български _алчен_). Това не винаги е най-опитмалната стратегия. Представете си, че разполагаме с монети от 1, 5, 10, 20, 25 стотинки, а трябва да върнем 40 стотинки. Алчения алгоритъм ще ни даде решение от 3 монети - 25, 10, 5, докато оптималното би било - само от 2 монети - от 2 по 20 стотинки 

За щастие задачата им _optimal substructure_ (или на български _оптимална подструктура_). Това означава, че ако разбием задачата на по-малки и намерим оптималното решение за всяка от тях, това е оптималното решение и на голямата задача.

Нека дадем пример с нашата задача. Разполагаме с монети от 1, 2 и 5 стотинки. Сумата, която искаме да върнем е 9 стотинки. 

Ще пробваме всяка една от монетите, като ги извадим от нашата сума. Ще получим разлика, която ще се опитаме да представим с минимален брой монети. След това ще видим, коя от монетите е дала минималния брой и това е решението на задачата. Така разбихме задачата на 3 подзадачи. 
  Продължаваме да решаваме подзадачите по същия начин. Нека разбием подзадачата за 8 стотинки. Отново имаме 3 опции, като всяка от тях трябва да решим поотделно и да видим коя от тях дава най-малко решение.

Продължаваме с решаването на подзадачата за 7 стотинки. Отново имаме 3 опции. Продълажаваме с решаването на подзадачата за 4 стотинки. Този път имаме само 2 опции защото не можем да изразим 4 стотинки с монети от 5 стотинки. 

Може би забелязахте, че често ни се налага да решаваме една и съща подзадача: задачата за 7, 6, 3 и 2 стотинки се повтаря.

С помощта на техниката dynamic programming или на български _динамично програмиране_  ще си спестим постоянното пресмятане на една и съща сума. Динамичното програмиране е въведено от американския математик Ричард Ърнест Белман през 1953-та година. Ще се опитам да обясня принципа нетехнически на дъщеря ми, която е на 14 години.

- Али, колко монетки виждаш на екрана?
- 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 
- Добре. А сега ще добавя още една. Колко станаха?
- Ами 12, много ясно.
- Как успя да ги преброиш толкова бързо?
- Не съм ги броила! Запомних, че има 11 и като добавим още 1 стават 12.
- Супер - това е динамично програмиране: да запомним някъде резултата от предишна подзадача и да си спестим усилието при решаването на задачата, която я включва. 

Ето как ще приложим тази техника за ефективно решаване на задачата на езика Python.

Ще си създадем един един списък, с размер с единица по-голям от сумата, която търсим - в този случай с 10 клетки за сума от 9 стотинки. Всеки един индекс в масива представлява подсума, а стойността му - минималния брой монети за да се достигне. Крайното решение на задачата ще се намира в последната клетка на масива. Във втори списък ще пазим монетата, с която сме постигнали тази сума. Той ще ни позволи да възпроизведем редицата от монети, които са довели до минималната сума.

Започваме с подсума 0 която не може да се изрази с монети. 

Започваме да пресмятаме броя на монетите за всяка една подсума докато стигнем до сумата, която търсим. Ще пробваме със всяка от монетите, като използваме изчисленията от предишните итерации. Така лесно ще намерим, с коя от 3-те монети достигаме до минимален брой. След това ще го запишем в масива и ще го използваме в следващите итерации или за намиране на крайното решение. 

В долната част на екрана можете да видите как се променят променливите при изпълнение на програмата. Постарал съм се имената на променливите да са максимално описателни (а не n, i, j, k) за максимално улеснение.

Като самостоятелна работа, опитайте се да отговорите на следните въпроси във коментарите:
* коя е точно поредицата от монети, която дава търсената сума?
* защо някои променливи или списъци са инициализирани с None, а други с безкрайност?
* какво означава, когато prev_amount е 0 и какво като е отрицателен?

В описанието на клипа съм сложи бърза навигация до всяка подсума, а може да ползвате контрола на скоростта на плеъра (двойна или наполовина) да ускорити или забавите изпълнението. 

Всичкия код е достъпен в Github като съм добавил линк в описанието.

Благодаря за вниманието.


   



# Източници
* https://algorithmist.com/wiki/Min-Coin_change
* https://en.wikipedia.org/wiki/Optimal_substructure
* https://medium.com/@trykv/how-to-solve-minimum-coin-change-f96a758ccade



