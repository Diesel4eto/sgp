# Mergesort (Сортиране чрез сливане)

Mergesort или на български _сортиране чрез сливане_ е алгоритъм за подреждане на _списък от елементи_ в нарастващ или намаляващ ред. Елементите могат да бъда числа, стрингове (или на български _символни низове_), но могат да бъдат и произволни други неща, стига да можем да установим между две от тях кое е по-голямото, по-малкото или са равни.

        8    3 
        3    5
        17   8 
        5    17
        
        вишна     авокадо      
        авокадо   банан
        ябълка    вишна
        банан     ябълка
        
        ♥️ ♠️
        ️♣ ♥️
        ♠️ ♦
        ♦ ♣️
               
Алгоритъмът е _стабилен_ - с други думи елементи, които са равни не си сменят реда, в който са в оригиналния списък. Може би се питате "какво значение има че не си сменят реда - нали са равни?". Стабилността ни позволява лесно да сортираме списък по повече от един критерий.
 
 Примерно ученици в клас, подредени по собствено и след това по фамилно име. Със стабилен алгоритъм за сортиране е достатъчно да сортираме списъка първо по собствено име и след това да сортираме резултата втори път, този път като използваме фамилното име.

    Александър Петров
    Борис Симеонов
    Борис Георгиев
    Александър Иванов
    
    Александър Петров
    Александър Иванов    
    Борис Симеонов
    Борис Георгиев
    
    Александър Иванов    
    Александър Петров
    Борис Георгиев
    Борис Симеонов

Нестабилния сортиращ алгоритъм не би ни гарантирал, че след второто сортиране, учениците ще запазят реда си по собствено име.
            
Сложността на алгоритъма или колко по-бавен става спрямо размера на входните данни в най-лошия случай е O(n log n), където n е броя на елементите в списъка. Това е добра производителност за сортиращ алгоритъм. Можете да си го представите че ако удвоите размера на елементите, то сложността ще се увеличи само с константа.

Алгоритъмът е измислен от Джон фон Нойман (John von Neumann) през 1945 година. Използва се техниката _divide-and-conquer_ (или на български _разделяй и владей_), която представлява разбиване на задачата на по-малки задачи или  _подзадачи_, решаване на всяка подзадача по отделно и след това обединяване на резултата. Всяка подзадача може да бъде разбита на още под-подзадачи и така нататък докато се стигне до достатъчно проста подзадача, така че тя да бъде решена самостоятелно. Може би вече сте се досетили, че такъв тип техника се релазира най-лесно, удобно и разбираемо с _рекурсия_. За рекурсия ще си говорим в някое сладващо видео.

Какви са стъпките на алгоритъма за merge sort:
1. Разделяме списъка на подсписъци, докато стигнем до подсписък само с 1 елемент. Списък с един елемент се счита за сортиран
2. **Сливаме съседни двойки от сортирани списъци като създаваме нов списък, в който запазваме подредбата**.
3. Продължаваме докато остане един списък. Това е подредения списък

Нека разгледаме в детайли всяка стъпка.

Първата стъпка е доста интуитивна:


Сливането на списъци от 1 елемент също е интуитивно - ако единствения елемент в левия списък е по-малък от единствения елемент в десния списък, тогава ги записваме в новия списък в точно този ред. Ако е обратното - в обратния ред


Сливането на списъци с 2 или повече елемента е по-малко интуитивно, но лесно разбирамо. Идеята е да държим 2 променливи - по една за всеки списък - към текущ елемент на списъка. Първоначално и двете променливи сочат началото на списъка. Сравняваме елементите, които в момента са посочени. Ако елемента от левия списък е по-малък от текущия в десния списък, тогава го прехвърляме в новия списък и се преместваме на следващия. Ако е обратното, т.е. десния елемент да е по-малък, тогава взимаме него и се преместваме на следващия. Продължаваме така докато свършат елементите. Може би вече сте забелязали, че по този начин можем да слеем и с 1 елемент.

Тъй като задачата се разбива на независими подзадачи, този алгоритъм може сравнително лесно може да се паралелезира. С други думи да стане по-бърз за изпълнение като разпредели работата върху множество процесорни ядра. 

Друго приложение е при сортиране на огромни списъци, които не могат да се поберат в оперативната памет изцяло. Те ще могат да се сортират "на парче", отделно, индивидуално и накарая да се произведе крайния резултат.








